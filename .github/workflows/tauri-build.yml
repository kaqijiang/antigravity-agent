name: Reusable Tauri Build

on:
  workflow_call:
    inputs:
      tag:
        description: "Release tag to upload assets to"
        required: true
        type: string
      ref:
        description: "Git ref to checkout (optional)"
        required: false
        type: string
      version:
        description: "Version for filenames (optional)"
        required: false
        type: string
      cache_key_suffix:
        description: "Suffix for rust-cache shared key"
        required: false
        type: string
        default: "build"
    secrets:
      TAURI_SIGNING_PRIVATE_KEY:
        required: true
      TAURI_SIGNING_PRIVATE_KEY_PASSWORD:
        required: true

permissions:
  contents: write

env:
  CARGO_TERM_COLOR: always

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: macos-latest
            arch: aarch64
            runs-on: macos-latest
            target: aarch64-apple-darwin
          - platform: macos-latest
            arch: x86_64
            runs-on: macos-latest
            target: x86_64-apple-darwin
          - platform: ubuntu-22.04
            arch: x86_64
            runs-on: ubuntu-22.04
            target: x86_64-unknown-linux-gnu
          - platform: windows-latest
            arch: x86_64
            runs-on: windows-latest
            target: x86_64-pc-windows-msvc

    runs-on: ${{ matrix.runs-on }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref != '' && inputs.ref || github.ref }}

      - name: Install dependencies (ubuntu only)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            libgtk-3-dev \
            libwebkit2gtk-4.1-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf

      - name: Rust setup
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'
          cache-on-failure: true
          cache-targets: true
          shared-key: tauri-${{ matrix.platform }}-${{ inputs.cache_key_suffix }}

      - name: Sync node version and setup cache
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'
          cache: 'npm'

      - name: Install frontend dependencies
        run: npm ci

      - name: Clean previous bundles
        shell: bash
        run: |
          rm -rf "src-tauri/target/${{ matrix.target }}/release/bundle" || true

      - name: Build with Tauri
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          RUST_LOG: debug
        shell: bash
        run: |
          echo "Building for target ${{ matrix.target }}..."
          npm run tauri:build -- --target ${{ matrix.target }} --verbose

      - name: Process and rename artifacts
        shell: bash
        run: |
          echo "=== Starting file rename process ==="
          BUNDLE_DIR="src-tauri/target/${{ matrix.target }}/release/bundle"
          PLATFORM="${{ matrix.platform }}"
          ARCH="${{ matrix.arch }}"
          VERSION="${{ inputs.version }}"

          rename_with_sig() {
            local file="$1"
            local new_name="$2"

            if [ ! -f "$file" ] || [ "$file" = "$new_name" ]; then
              return 0
            fi

            mv "$file" "$new_name"
            if [ -f "${file}.sig" ]; then
              mv "${file}.sig" "${new_name}.sig"
            fi
          }

          if [ ! -d "$BUNDLE_DIR" ]; then
            echo "❌ Bundle directory not found: $BUNDLE_DIR"
            echo "Searching for bundle directories:"
            find src-tauri/target -type d -name "bundle" 2>/dev/null || true
            exit 1
          fi

          if [ -n "$VERSION" ]; then
            AG_NAME_MID="_${VERSION}"
            AG_LINUX_MID="_${VERSION}"
          else
            AG_NAME_MID=""
            AG_LINUX_MID=""
          fi

          # macOS
          if [ "$PLATFORM" = "macos-latest" ]; then
            if [ -d "$BUNDLE_DIR/dmg" ]; then
              (
                cd "$BUNDLE_DIR/dmg/"
                for file in *.dmg; do
                  if [ -f "$file" ]; then
                    rename_with_sig "$file" "Antigravity.Agent${AG_NAME_MID}_${ARCH}.dmg"
                  fi
                done
              )
            fi

            # updater bundle (required for macOS auto-update)
            if [ -d "$BUNDLE_DIR/macos" ]; then
              (
                cd "$BUNDLE_DIR/macos/"
                for file in *.app.tar.gz; do
                  if [ -f "$file" ]; then
                    rename_with_sig "$file" "Antigravity.Agent${AG_NAME_MID}_${ARCH}.app.tar.gz"
                  fi
                done
              )
            fi
          fi

          # Windows
          if [ "$PLATFORM" = "windows-latest" ]; then
            if [ -d "$BUNDLE_DIR/msi" ]; then
              (
                cd "$BUNDLE_DIR/msi/"
                for file in *.msi *.msi.zip; do
                  if [ -f "$file" ]; then
                    if echo "$file" | grep -q "\\.msi\\.zip$"; then
                      rename_with_sig "$file" "Antigravity.Agent${AG_NAME_MID}_x64-setup.msi.zip"
                    else
                      rename_with_sig "$file" "Antigravity.Agent${AG_NAME_MID}_x64-setup.msi"
                    fi
                  fi
                done
              )
            fi

            if [ -d "$BUNDLE_DIR/nsis" ]; then
              (
                cd "$BUNDLE_DIR/nsis/"
                for file in *.exe *.nsis.zip; do
                  if [ -f "$file" ]; then
                    if echo "$file" | grep -q "\\.nsis\\.zip$"; then
                      rename_with_sig "$file" "Antigravity.Agent${AG_NAME_MID}_x64-setup.nsis.zip"
                    else
                      rename_with_sig "$file" "Antigravity.Agent${AG_NAME_MID}_x64-setup.exe"
                    fi
                  fi
                done
              )
            fi
          fi

          # Linux
          if [ "$PLATFORM" = "ubuntu-22.04" ]; then
            if [ -d "$BUNDLE_DIR/appimage" ]; then
              (
                cd "$BUNDLE_DIR/appimage/"
                for file in *.AppImage *.AppImage.tar.gz; do
                  if [ -f "$file" ]; then
                    if echo "$file" | grep -q "\\.AppImage\\.tar\\.gz$"; then
                      rename_with_sig "$file" "antigravity-agent${AG_LINUX_MID}_amd64.AppImage.tar.gz"
                    else
                      rename_with_sig "$file" "antigravity-agent${AG_LINUX_MID}_amd64.AppImage"
                    fi
                  fi
                done
              )
            fi

            if [ -d "$BUNDLE_DIR/deb" ]; then
              (
                cd "$BUNDLE_DIR/deb/"
                for file in *.deb; do
                  if [ -f "$file" ]; then
                    rename_with_sig "$file" "antigravity-agent${AG_LINUX_MID}_amd64.deb"
                  fi
                done
              )
            fi
          fi

      - name: Create Windows Portable Version
        if: matrix.platform == 'windows-latest'
        shell: pwsh
        run: |
          Write-Host "=== Creating Windows Portable Version ==="

          $exePath = "src-tauri\target\${{ matrix.target }}\release\antigravity-agent.exe"
          $outputDir = "portable-package"
          $bundleDir = "src-tauri\target\${{ matrix.target }}\release\bundle"
          $zipPath = "$bundleDir\Antigravity-Agent-${{ matrix.arch }}-Portable.zip"

          if (!(Test-Path $bundleDir)) {
            New-Item -ItemType Directory -Force -Path $bundleDir | Out-Null
          }

          if (Test-Path $exePath) {
            New-Item -ItemType Directory -Force -Path $outputDir | Out-Null
            Copy-Item $exePath "$outputDir\Antigravity.Agent.exe"
            Compress-Archive -Path "$outputDir\*" -DestinationPath $zipPath -Force
            Remove-Item -Recurse -Force $outputDir
          } else {
            Write-Host "❌ Exe file not found: $exePath"
          }

      - name: Upload artifacts to release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG: ${{ inputs.tag }}
          REPO: ${{ github.repository }}
        shell: bash
        run: |
          echo "=== Starting upload process for tag: $TAG ==="
          BUNDLE_DIR="src-tauri/target/${{ matrix.target }}/release/bundle"

          if [ ! -d "$BUNDLE_DIR" ]; then
            echo "❌ Bundle directory not found: $BUNDLE_DIR"
            exit 1
          fi

          find "$BUNDLE_DIR" -type f \( \
            -name "*.msi" -o -name "*.exe" -o -name "*.zip" -o \
            -name "*.AppImage" -o -name "*.AppImage.tar.gz" -o -name "*.deb" -o \
            -name "*.sig" -o -name "*.dmg" -o -name "*.app.tar.gz" \
          \) | while IFS= read -r file; do
            echo "Uploading: $file"
            gh release upload "$TAG" "$file" --clobber --repo "$REPO"
          done
